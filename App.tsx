import React, { useState, useCallback, useMemo, useEffect, useRef } from 'react';
import InfiniteGraph from './components/InfiniteGraph';
import Controls from './components/Controls';
import { Viewport, Theme, Point } from './types';
import { createTransformFunction } from './utils/math';
import { getRowOffset, pointKey } from './utils/grid';

const STORAGE_KEY = 'gcdgraph-settings';
const DEFAULT_VIEWPORT: Viewport = { x: 12, y: 8, zoom: 45 };
const MAX_HIGHLIGHT_POINTS = 500;
const DEFAULT_COORD_CAP = 50000;

interface HighlightRange {
  min: number;
  max: number;
}

const dedupePoints = (points: Point[]) => {
  const seen = new Set<string>();
  const result: Point[] = [];
  points.forEach((p) => {
    const x = Math.round(Number(p.x));
    const y = Math.round(Number(p.y));
    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
    const key = pointKey({ x, y });
    if (seen.has(key)) return;
    seen.add(key);
    result.push({ x, y });
  });
  return result;
};

const clampInt = (val: number, fallback: number, min: number, max: number) => {
  if (!Number.isFinite(val)) return fallback;
  return Math.min(max, Math.max(min, Math.round(val)));
};

function App() {
  // Initial view centered slightly positive to show interesting initial structure
  const [viewport, setViewport] = useState<Viewport>(DEFAULT_VIEWPORT);

  const [theme, setTheme] = useState<Theme>('light');
  const [transformFunc, setTransformFunc] = useState<string>('n');
  const [simpleView, setSimpleView] = useState(false);
  const [showFactored, setShowFactored] = useState(true);
  const [rowShift, setRowShift] = useState<number>(0);
  const [shiftLock, setShiftLock] = useState<boolean>(false);
  const [randomizeShift, setRandomizeShift] = useState<boolean>(false);
  const [cursorPos, setCursorPos] = useState<Point>({ x: 0, y: 0 });
  const [degree, setDegree] = useState<number>(1);
  const [resetPathsSignal, setResetPathsSignal] = useState<number>(0);

  const [autoHighlightExpr, setAutoHighlightExpr] = useState<string>('');
  const [autoHighlightRange, setAutoHighlightRange] = useState<HighlightRange>({ min: 1, max: 25 });
  const [coordinateCap, setCoordinateCap] = useState<number>(DEFAULT_COORD_CAP);
  const [pathStepLimit, setPathStepLimit] = useState<number>(5000);
  const [backtraceLimit, setBacktraceLimit] = useState<number>(4000);

  const [manualNodes, setManualNodes] = useState<Point[]>([]);
  const [autoGeneratedNodes, setAutoGeneratedNodes] = useState<Point[]>([]);

  const [settingsLoaded, setSettingsLoaded] = useState(false);
  const prevRowShiftConfig = useRef<{ k: number; randomize: boolean }>({
    k: rowShift,
    randomize: randomizeShift
  });

  // Load persisted settings
  useEffect(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      setSettingsLoaded(true);
      return;
    }
    try {
      const data = JSON.parse(raw);
      if (data.viewport) setViewport(data.viewport);
      if (data.theme) setTheme(data.theme);
      if (typeof data.transformFunc === 'string') setTransformFunc(data.transformFunc);
      if (typeof data.simpleView === 'boolean') setSimpleView(data.simpleView);
      if (typeof data.showFactored === 'boolean') setShowFactored(data.showFactored);
      if (Number.isFinite(data.rowShift)) setRowShift(clampInt(data.rowShift, 0, 0, 210));
      if (typeof data.shiftLock === 'boolean') setShiftLock(data.shiftLock);
      if (typeof data.randomizeShift === 'boolean') setRandomizeShift(data.randomizeShift);
      if (Number.isFinite(data.degree)) setDegree(clampInt(data.degree, 1, 1, 4));
      if (typeof data.autoHighlightExpr === 'string') setAutoHighlightExpr(data.autoHighlightExpr);
      if (data.autoHighlightRange) {
        setAutoHighlightRange({
          min: clampInt(data.autoHighlightRange.min, 1, -2000, 2000),
          max: clampInt(data.autoHighlightRange.max, 25, -2000, 2000)
        });
      }
      if (Number.isFinite(data.coordinateCap)) setCoordinateCap(clampInt(data.coordinateCap, DEFAULT_COORD_CAP, 10, 200000));
      if (Number.isFinite(data.pathStepLimit)) setPathStepLimit(clampInt(data.pathStepLimit, 5000, 10, 50000));
      if (Number.isFinite(data.backtraceLimit)) setBacktraceLimit(clampInt(data.backtraceLimit, 4000, 10, 50000));
      if (Array.isArray(data.manualNodes)) setManualNodes(dedupePoints(data.manualNodes));
      if (Array.isArray(data.autoGeneratedNodes)) setAutoGeneratedNodes(dedupePoints(data.autoGeneratedNodes));
    } catch (err) {
      console.error('Failed to load settings', err);
    } finally {
      setSettingsLoaded(true);
    }
  }, []);

  // Persist settings
  useEffect(() => {
    if (!settingsLoaded) return;
    const payload = {
      viewport,
      theme,
      transformFunc,
      simpleView,
      showFactored,
      rowShift,
      shiftLock,
      randomizeShift,
      degree,
      autoHighlightExpr,
      autoHighlightRange,
      coordinateCap,
      pathStepLimit,
      backtraceLimit,
      manualNodes,
      autoGeneratedNodes
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }, [
    settingsLoaded,
    viewport,
    theme,
    transformFunc,
    simpleView,
    showFactored,
    rowShift,
    shiftLock,
    randomizeShift,
    degree,
    autoHighlightExpr,
    autoHighlightRange,
    coordinateCap,
    pathStepLimit,
    backtraceLimit,
    manualNodes,
    autoGeneratedNodes
  ]);

  // Shift manual path starts when unlocked so they follow row adjustments
  useEffect(() => {
    const previous = prevRowShiftConfig.current;
    const sameConfig = previous.k === rowShift && previous.randomize === randomizeShift;

    if (shiftLock || sameConfig) {
      prevRowShiftConfig.current = { k: rowShift, randomize: randomizeShift };
      return;
    }

    setManualNodes((starts) => {
      if (starts.length === 0) return starts;

      let changed = false;
      const next = starts.map((p) => {
        const delta =
          getRowOffset(p.y, rowShift, randomizeShift) - getRowOffset(p.y, previous.k, previous.randomize);
        if (delta === 0) return p;
        changed = true;
        return { ...p, x: p.x + delta };
      });

      return changed ? next : starts;
    });

    prevRowShiftConfig.current = { k: rowShift, randomize: randomizeShift };
  }, [rowShift, shiftLock, randomizeShift]);

  const sanitizedRange = useMemo(() => {
    const min = clampInt(autoHighlightRange.min, 1, -2000, 2000);
    const max = clampInt(autoHighlightRange.max, 25, -2000, 2000);
    return {
      min: Math.min(min, max),
      max: Math.max(min, max)
    };
  }, [autoHighlightRange]);

  const evaluateAutoExpr = useCallback(
    (expr: string) => {
      const trimmed = expr.trim();
      if (!trimmed) return { points: [] as Point[], error: '' };

      const tupleMatch = trimmed.match(/^\s*\(?\s*(.+)\s*,\s*(.+)\b\s*\)?\s*$/);
      if (!tupleMatch) {
        return { points: [] as Point[], error: 'Use format (xExpr, yExpr) with comma-separated expressions in n.' };
      }

      const xExpr = tupleMatch[1];
      const yExpr = tupleMatch[2];
      console.log('Evaluating auto highlight expressions:', { xExpr, yExpr });
      const xFn = createTransformFunction(xExpr);
      const yFn = createTransformFunction(yExpr);

      const startN = Math.round(sanitizedRange.min);
      const endN = Math.round(sanitizedRange.max);
      const total = endN - startN + 1;
      if (total > MAX_HIGHLIGHT_POINTS) {
        return { points: [] as Point[], error: `Range too large (max ${MAX_HIGHLIGHT_POINTS} values).` };
      }

      const points: Point[] = [];
      const seen = new Set<string>();

      for (let n = startN; n <= endN; n++) {
        const xVal = xFn(n);
        const yVal = yFn(n);
        const x = Math.round(xVal);
        const y = Math.round(yVal);

        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return { points: [] as Point[], error: 'Expression produced a non-finite value.' };
        }

        if (Math.abs(x) > coordinateCap || Math.abs(y) > coordinateCap) {
          return {
            points: [] as Point[],
            error: `Values exceed coordinate cap (${coordinateCap}). Reduce n range or cap.`
          };
        }

        const key = pointKey({ x, y });
        if (!seen.has(key)) {
          seen.add(key);
          points.push({ x, y });
        }
      }

      return { points, error: '' };
    },
    [sanitizedRange, coordinateCap]
  );

  const autoHighlightResult = useMemo(
    () => evaluateAutoExpr(autoHighlightExpr),
    [autoHighlightExpr, evaluateAutoExpr]
  );

  const togglePathStart = useCallback((p: Point) => {
    const key = pointKey(p);
    setManualNodes((prev) => {
      if (prev.some((pt) => pointKey(pt) === key)) {
        return prev.filter((pt) => pointKey(pt) !== key);
      }
      return [...prev, p];
    });
  }, []);

  const applyAutoHighlight = useCallback(
    (expr: string) => {
      const result = evaluateAutoExpr(expr);
      setAutoHighlightExpr(expr);
      if (result.error || result.points.length === 0) {
        setAutoGeneratedNodes([]);
        return;
      }

      const autoKeys = new Set(autoGeneratedNodes.map((p) => pointKey(p)));
      setManualNodes((prev) => {
        const retained = prev.filter((p) => !autoKeys.has(pointKey(p)));
        return dedupePoints([...retained, ...result.points]);
      });
      setAutoGeneratedNodes(result.points);
    },
    [evaluateAutoExpr, autoGeneratedNodes]
  );

  const resetPaths = useCallback(() => {
    setManualNodes([]);
    setAutoGeneratedNodes([]);
    setResetPathsSignal((s) => s + 1);
  }, []);

  const handleRangeChange = useCallback((next: Partial<HighlightRange>) => {
    setAutoHighlightRange((prev) => {
      const updated = { ...prev, ...next };
      return {
        min: clampInt(updated.min, 1, -2000, 2000),
        max: clampInt(updated.max, 25, -2000, 2000)
      };
    });
  }, []);

  const handleCoordinateCap = useCallback(
    (val: number) => setCoordinateCap(clampInt(val, coordinateCap, 10, 200000)),
    [coordinateCap]
  );

  const handlePathStepLimit = useCallback(
    (val: number) => setPathStepLimit(clampInt(val, pathStepLimit, 10, 50000)),
    [pathStepLimit]
  );

  const handleBacktraceLimit = useCallback(
    (val: number) => setBacktraceLimit(clampInt(val, backtraceLimit, 10, 50000)),
    [backtraceLimit]
  );

  return (
    <div
      className={`relative w-full h-full overflow-hidden transition-colors duration-300 select-none ${
        theme === 'dark' ? 'bg-gray-900' : 'bg-gray-50'
      }`}
    >
      <InfiniteGraph
        viewport={viewport}
        onViewportChange={setViewport}
        theme={theme}
        transformFunc={transformFunc}
        simpleView={simpleView}
        showFactored={showFactored}
        rowShift={rowShift}
        randomizeShift={randomizeShift}
        onCursorMove={setCursorPos}
        degree={degree}
        resetPathsSignal={resetPathsSignal}
        pathStarts={manualNodes}
        onTogglePathStart={togglePathStart}
        pathStepLimit={pathStepLimit}
        pathCoordinateCap={coordinateCap}
        backtraceLimit={backtraceLimit}
      />
      <Controls
        viewport={viewport}
        setViewport={setViewport}
        theme={theme}
        setTheme={setTheme}
        transformFunc={transformFunc}
        setTransformFunc={setTransformFunc}
        simpleView={simpleView}
        setSimpleView={setSimpleView}
        showFactored={showFactored}
        setShowFactored={setShowFactored}
        rowShift={rowShift}
        setRowShift={setRowShift}
        shiftLock={shiftLock}
        setShiftLock={setShiftLock}
        randomizeShift={randomizeShift}
        setRandomizeShift={setRandomizeShift}
        cursorPos={cursorPos}
        degree={degree}
        setDegree={setDegree}
        onResetPaths={resetPaths}
        autoHighlightExpr={autoHighlightExpr}
        onApplyAutoHighlight={applyAutoHighlight}
        autoHighlightError={autoHighlightResult.error}
        autoHighlightRange={sanitizedRange}
        setAutoHighlightRange={handleRangeChange}
        coordinateCap={coordinateCap}
        setCoordinateCap={handleCoordinateCap}
        pathStepLimit={pathStepLimit}
        setPathStepLimit={handlePathStepLimit}
        backtraceLimit={backtraceLimit}
        setBacktraceLimit={handleBacktraceLimit}
      />
      {/* Branding / Watermark */}
      <div className="absolute bottom-4 left-4 pointer-events-none opacity-50">
        <span className={`text-xs font-mono ${theme === 'dark' ? 'text-gray-600' : 'text-gray-400'}`}>
          Infinite GCD Explorer
        </span>
      </div>
    </div>
  );
}

export default App;
