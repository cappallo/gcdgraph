import React, {
  useState,
  useCallback,
  useMemo,
  useEffect,
  useRef,
} from "react";
import InfiniteGraph from "./components/InfiniteGraph";
import Controls from "./components/Controls";
import { Viewport, Theme, Point } from "./types";
import { createTransformFunction, gcd, gcdBigInt, isPrime } from "./utils/math";
import { getRowOffset, getRowShiftMagnitude, pointKey } from "./utils/grid";
import {
  compileMoveRightPredicate,
  DEFAULT_MOVE_RIGHT_EXPR,
} from "./utils/moveRule";

const STORAGE_KEY = "gcdgraph-settings";
const SETTINGS_SLOTS_KEY = "gcdgraph-settings-slots";
const DEFAULT_VIEWPORT: Viewport = { x: 12, y: 8, zoom: 45 };
const DEFAULT_ROW_SHIFT_BOUNDS = { min: -210, max: 210 };
const MAX_HIGHLIGHT_POINTS = 500;
const MAX_SAVED_NODES = 5000;

declare global {
  interface Window {
    __GCDGRAPH_SAFE_MODE__?: boolean;
  }
}

interface HighlightRange {
  min: number;
  max: number;
}

interface RowShiftBounds {
  min: number;
  max: number;
}

interface SettingsSnapshot {
  viewport: Viewport;
  theme: Theme;
  transformFunc: string;
  moveRightExpr: string;
  simpleView: boolean;
  showFactored: boolean;
  rowShift: number;
  shiftLock: boolean;
  randomizeShift: boolean;
  degree: number;
  autoHighlightExpr: string;
  autoHighlightEnabled: boolean;
  autoHighlightGoToGround: boolean;
  autoHighlightRange: HighlightRange;
  rowShiftBounds: RowShiftBounds;
  pathStepLimit: number;
  backtraceLimit: number;
  manualNodes: Point[];
  autoGeneratedNodes: Point[];
}

interface SavedSettingsSlot {
  id: string;
  description: string;
  savedAt: number;
  snapshot: SettingsSnapshot;
}

const DEFAULT_SETTINGS_SNAPSHOT: SettingsSnapshot = {
  viewport: DEFAULT_VIEWPORT,
  theme: "light",
  transformFunc: "n",
  moveRightExpr: DEFAULT_MOVE_RIGHT_EXPR,
  simpleView: false,
  showFactored: true,
  rowShift: 0,
  shiftLock: false,
  randomizeShift: false,
  degree: 1,
  autoHighlightExpr: "",
  autoHighlightEnabled: false,
  autoHighlightGoToGround: false,
  autoHighlightRange: { min: 1, max: 25 },
  rowShiftBounds: DEFAULT_ROW_SHIFT_BOUNDS,
  pathStepLimit: 10000,
  backtraceLimit: 100000,
  manualNodes: [],
  autoGeneratedNodes: [],
};

const dedupePoints = (points: Point[]) => {
  const seen = new Set<string>();
  const result: Point[] = [];
  points.forEach((p) => {
    const x = Math.round(Number(p.x));
    const y = Math.round(Number(p.y));
    if (!Number.isFinite(x) || !Number.isFinite(y)) return;
    const key = pointKey({ x, y });
    if (seen.has(key)) return;
    seen.add(key);
    result.push({ x, y });
  });
  return result;
};

const clampInt = (val: number, fallback: number, min: number, max: number) => {
  if (!Number.isFinite(val)) return fallback;
  return Math.min(max, Math.max(min, Math.round(val)));
};

const resolveRowShiftBounds = (
  next: Partial<RowShiftBounds> | undefined,
  fallback: RowShiftBounds
) => {
  const minRaw =
    typeof next?.min === "number" ? next.min : fallback.min;
  const maxRaw =
    typeof next?.max === "number" ? next.max : fallback.max;
  const min = clampInt(minRaw, fallback.min, -210, 210);
  const max = clampInt(maxRaw, fallback.max, -210, 210);
  return { min: Math.min(min, max), max: Math.max(min, max) };
};

function App() {
  const safeMode = window.__GCDGRAPH_SAFE_MODE__ === true;
  // Initial view centered slightly positive to show interesting initial structure
  const [viewport, setViewport] = useState<Viewport>(DEFAULT_VIEWPORT);

  const [theme, setTheme] = useState<Theme>("light");
  const [transformFunc, setTransformFunc] = useState<string>("n");
  const [moveRightExpr, setMoveRightExpr] = useState<string>(
    DEFAULT_MOVE_RIGHT_EXPR
  );
  const [simpleView, setSimpleView] = useState(false);
  const [showFactored, setShowFactored] = useState(true);
  const [rowShift, setRowShift] = useState<number>(0);
  const [rowShiftBounds, setRowShiftBounds] =
    useState<RowShiftBounds>(DEFAULT_ROW_SHIFT_BOUNDS);
  const [shiftLock, setShiftLock] = useState<boolean>(false);
  const [randomizeShift, setRandomizeShift] = useState<boolean>(false);
  const [cursorPos, setCursorPos] = useState<Point>({ x: 0, y: 0 });
  const [degree, setDegree] = useState<number>(1);
  const [resetPathsSignal, setResetPathsSignal] = useState<number>(0);

  const [autoHighlightExpr, setAutoHighlightExpr] = useState<string>("");
  const [autoHighlightEnabled, setAutoHighlightEnabled] =
    useState<boolean>(false);
  const [autoHighlightGoToGround, setAutoHighlightGoToGround] =
    useState<boolean>(false);
  const [autoHighlightRange, setAutoHighlightRange] = useState<HighlightRange>({
    min: 1,
    max: 25,
  });
  const [pathStepLimit, setPathStepLimit] = useState<number>(10000);
  const [backtraceLimit, setBacktraceLimit] = useState<number>(100000);
  const [backtrailLength, setBacktrailLength] = useState<number | null>(null);

  const [manualNodes, setManualNodes] = useState<Point[]>([]);
  const [autoGeneratedNodes, setAutoGeneratedNodes] = useState<Point[]>([]);
  const autoGeneratedNodesRef = useRef<Point[]>([]);

  const [savedSlots, setSavedSlots] = useState<SavedSettingsSlot[]>([]);
  const [settingsLoaded, setSettingsLoaded] = useState(false);
  const [slotsLoaded, setSlotsLoaded] = useState(false);

  const rowShiftRef = useRef(rowShift);
  const randomizeShiftRef = useRef(randomizeShift);
  const rowShiftBoundsRef = useRef<RowShiftBounds>(rowShiftBounds);

  const prevRowShiftConfig = useRef<{ k: number; randomize: boolean }>({
    k: rowShift,
    randomize: randomizeShift,
  });

  useEffect(() => {
    rowShiftRef.current = rowShift;
  }, [rowShift]);

  useEffect(() => {
    randomizeShiftRef.current = randomizeShift;
  }, [randomizeShift]);

  useEffect(() => {
    rowShiftBoundsRef.current = rowShiftBounds;
  }, [rowShiftBounds]);

  useEffect(() => {
    autoGeneratedNodesRef.current = autoGeneratedNodes;
  }, [autoGeneratedNodes]);

  const createSlotId = () => {
    if (typeof crypto !== "undefined" && "randomUUID" in crypto) {
      return crypto.randomUUID();
    }
    return `slot-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
  };

  const applySettingsSnapshot = useCallback(
    (
      data: Partial<SettingsSnapshot>,
      options?: { syncRowShift?: boolean }
    ) => {
      const currentRowShiftBounds = rowShiftBoundsRef.current;
      const currentRowShift = rowShiftRef.current;
      const currentRandomizeShift = randomizeShiftRef.current;

      const nextRowShiftBounds = resolveRowShiftBounds(
        data.rowShiftBounds,
        currentRowShiftBounds
      );
      const nextRowShift = Number.isFinite(data.rowShift)
        ? clampInt(
            data.rowShift,
            currentRowShift,
            nextRowShiftBounds.min,
            nextRowShiftBounds.max
          )
        : clampInt(
            currentRowShift,
            currentRowShift,
            nextRowShiftBounds.min,
            nextRowShiftBounds.max
          );
      const nextRandomizeShift =
        typeof data.randomizeShift === "boolean"
          ? data.randomizeShift
          : currentRandomizeShift;

      if (options?.syncRowShift) {
        prevRowShiftConfig.current = {
          k: nextRowShift,
          randomize: nextRandomizeShift,
        };

        rowShiftRef.current = nextRowShift;
        randomizeShiftRef.current = nextRandomizeShift;
        rowShiftBoundsRef.current = nextRowShiftBounds;
      }

      if (data.viewport) setViewport(data.viewport);
      if (data.theme) setTheme(data.theme);
      if (typeof data.transformFunc === "string")
        setTransformFunc(data.transformFunc);
      if (typeof data.moveRightExpr === "string")
        setMoveRightExpr(data.moveRightExpr);
      if (typeof data.simpleView === "boolean") setSimpleView(data.simpleView);
      if (typeof data.showFactored === "boolean")
        setShowFactored(data.showFactored);
      if (data.rowShiftBounds) setRowShiftBounds(nextRowShiftBounds);
      if (data.rowShiftBounds || Number.isFinite(data.rowShift))
        setRowShift(nextRowShift);
      if (typeof data.shiftLock === "boolean") setShiftLock(data.shiftLock);
      if (typeof data.randomizeShift === "boolean")
        setRandomizeShift(nextRandomizeShift);
      if (Number.isFinite(data.degree))
        setDegree(clampInt(data.degree, 1, 1, 4));
      if (typeof data.autoHighlightExpr === "string")
        setAutoHighlightExpr(data.autoHighlightExpr);
      if (typeof data.autoHighlightEnabled === "boolean")
        setAutoHighlightEnabled(data.autoHighlightEnabled);
      if (typeof (data as any).autoHighlightGoToGround === "boolean")
        setAutoHighlightGoToGround((data as any).autoHighlightGoToGround);
      if (data.autoHighlightRange) {
        setAutoHighlightRange({
          min: clampInt(data.autoHighlightRange.min, 1, -2000, 2000),
          max: clampInt(data.autoHighlightRange.max, 25, -2000, 2000),
        });
      }
      if (Number.isFinite(data.pathStepLimit))
        setPathStepLimit(clampInt(data.pathStepLimit, 10000, 1, 1000000));
      if (Number.isFinite(data.backtraceLimit))
        setBacktraceLimit(clampInt(data.backtraceLimit, 100000, 1, 1000000));
      if (Array.isArray(data.manualNodes)) {
        const sliced =
          data.manualNodes.length > MAX_SAVED_NODES
            ? data.manualNodes.slice(0, MAX_SAVED_NODES)
            : data.manualNodes;
        setManualNodes(dedupePoints(sliced));
      }
      if (Array.isArray(data.autoGeneratedNodes)) {
        const sliced =
          data.autoGeneratedNodes.length > MAX_SAVED_NODES
            ? data.autoGeneratedNodes.slice(0, MAX_SAVED_NODES)
            : data.autoGeneratedNodes;
        setAutoGeneratedNodes(dedupePoints(sliced));
      }
    },
    []
  );

  const buildSettingsSnapshot = useCallback(
    (): SettingsSnapshot => ({
      viewport,
      theme,
      transformFunc,
      moveRightExpr,
      simpleView,
      showFactored,
      rowShift,
      shiftLock,
      randomizeShift,
      degree,
      autoHighlightExpr,
      autoHighlightEnabled,
      autoHighlightGoToGround,
      autoHighlightRange: { ...autoHighlightRange },
      rowShiftBounds,
      pathStepLimit,
      backtraceLimit,
      manualNodes: dedupePoints(manualNodes),
      autoGeneratedNodes: dedupePoints(autoGeneratedNodes),
    }),
    [
      viewport,
      theme,
      transformFunc,
      moveRightExpr,
      simpleView,
      showFactored,
      rowShift,
      shiftLock,
      randomizeShift,
      degree,
      autoHighlightExpr,
      autoHighlightEnabled,
      autoHighlightGoToGround,
      autoHighlightRange,
      rowShiftBounds,
      pathStepLimit,
      backtraceLimit,
      manualNodes,
      autoGeneratedNodes,
    ]
  );

  // Load persisted settings
  useEffect(() => {
    if (window.__GCDGRAPH_SAFE_MODE__) {
      setSettingsLoaded(true);
      return;
    }
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) {
      setSettingsLoaded(true);
      return;
    }
    try {
      const data = JSON.parse(raw);
      applySettingsSnapshot(data, { syncRowShift: true });
    } catch (err) {
      console.error("Failed to load settings", err);
      try {
        localStorage.removeItem(STORAGE_KEY);
      } catch {}
    } finally {
      setSettingsLoaded(true);
    }
  }, []);

  // Load saved slots
  useEffect(() => {
    if (window.__GCDGRAPH_SAFE_MODE__) {
      setSlotsLoaded(true);
      return;
    }
    const raw = localStorage.getItem(SETTINGS_SLOTS_KEY);
    if (!raw) {
      setSlotsLoaded(true);
      return;
    }
    try {
      const data = JSON.parse(raw);
      if (Array.isArray(data)) {
        const cleaned = data
          .map((slot) => {
            if (!slot || typeof slot !== "object") return null;
            const description =
              typeof slot.description === "string"
                ? slot.description.trim()
                : "";
            if (!description) return null;
            const snapshot =
              slot.snapshot && typeof slot.snapshot === "object"
                ? slot.snapshot
                : null;
            if (!snapshot) return null;
            const id =
              typeof slot.id === "string" && slot.id
                ? slot.id
                : createSlotId();
            const savedAt = Number.isFinite(slot.savedAt)
              ? slot.savedAt
              : Date.now();
            return {
              id,
              description,
              savedAt,
              snapshot,
            } as SavedSettingsSlot;
          })
          .filter((slot): slot is SavedSettingsSlot => Boolean(slot));
        setSavedSlots(cleaned);
      }
    } catch (err) {
      console.error("Failed to load saved slots", err);
      try {
        localStorage.removeItem(SETTINGS_SLOTS_KEY);
      } catch {}
    } finally {
      setSlotsLoaded(true);
    }
  }, []);

  // Persist settings
  useEffect(() => {
    if (!settingsLoaded || safeMode) return;
    const payload = {
      viewport,
      theme,
      transformFunc,
      moveRightExpr,
      simpleView,
      showFactored,
      rowShift,
      shiftLock,
      randomizeShift,
      degree,
      autoHighlightExpr,
      autoHighlightEnabled,
      autoHighlightGoToGround,
      autoHighlightRange,
      rowShiftBounds,
      pathStepLimit,
      backtraceLimit,
      manualNodes,
      autoGeneratedNodes,
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  }, [
    settingsLoaded,
    safeMode,
    viewport,
    theme,
    transformFunc,
    moveRightExpr,
    simpleView,
    showFactored,
    rowShift,
    shiftLock,
    randomizeShift,
    degree,
    autoHighlightExpr,
    autoHighlightEnabled,
    autoHighlightGoToGround,
    autoHighlightRange,
    rowShiftBounds,
    pathStepLimit,
    backtraceLimit,
    manualNodes,
    autoGeneratedNodes,
  ]);

  // Persist saved slots
  useEffect(() => {
    if (!slotsLoaded || safeMode) return;
    localStorage.setItem(SETTINGS_SLOTS_KEY, JSON.stringify(savedSlots));
  }, [savedSlots, slotsLoaded, safeMode]);

  // Shift manual path starts when unlocked so they follow row adjustments
  useEffect(() => {
    const previous = prevRowShiftConfig.current;
    const sameConfig =
      previous.k === rowShift && previous.randomize === randomizeShift;

    if (shiftLock || sameConfig) {
      prevRowShiftConfig.current = { k: rowShift, randomize: randomizeShift };
      return;
    }

    setManualNodes((starts) => {
      if (starts.length === 0) return starts;

      let changed = false;
      const next = starts.map((p) => {
        const delta =
          getRowOffset(p.y, rowShift, randomizeShift) -
          getRowOffset(p.y, previous.k, previous.randomize);
        if (delta === 0) return p;
        changed = true;
        return { ...p, x: p.x + delta };
      });

      return changed ? next : starts;
    });

    prevRowShiftConfig.current = { k: rowShift, randomize: randomizeShift };
  }, [rowShift, shiftLock, randomizeShift]);

  const sanitizedRange = useMemo(() => {
    const min = clampInt(autoHighlightRange.min, 1, -2000, 2000);
    const max = clampInt(autoHighlightRange.max, 25, -2000, 2000);
    return {
      min: Math.min(min, max),
      max: Math.max(min, max),
    };
  }, [autoHighlightRange]);

  const evaluateAutoExpr = useCallback(
    (expr: string) => {
      const trimmed = expr.trim();
      if (!trimmed) return { points: [] as Point[], error: "" };

      const tupleMatch = trimmed.match(/^\s*\(?\s*(.+)\s*,\s*(.+)\b\s*\)?\s*$/);
      if (!tupleMatch) {
        return {
          points: [] as Point[],
          error:
            "Use format (xExpr, yExpr) with comma-separated expressions in n.",
        };
      }

      const xExpr = tupleMatch[1];
      const yExpr = tupleMatch[2];
      console.log("Evaluating auto highlight expressions:", { xExpr, yExpr });
      const xFn = createTransformFunction(xExpr);
      const yFn = createTransformFunction(yExpr);

      const startN = Math.round(sanitizedRange.min);
      const endN = Math.round(sanitizedRange.max);
      const total = endN - startN + 1;
      if (total > MAX_HIGHLIGHT_POINTS) {
        return {
          points: [] as Point[],
          error: `Range too large (max ${MAX_HIGHLIGHT_POINTS} values).`,
        };
      }

      const points: Point[] = [];
      const seen = new Set<string>();

      for (let n = startN; n <= endN; n++) {
        const xVal = xFn(n);
        const yVal = yFn(n);
        const x = Math.round(xVal);
        const y = Math.round(yVal);

        if (!Number.isFinite(x) || !Number.isFinite(y)) {
          return {
            points: [] as Point[],
            error: "Expression produced a non-finite value.",
          };
        }

        const key = pointKey({ x, y });
        if (!seen.has(key)) {
          seen.add(key);
          points.push({ x, y });
        }
      }

      return { points, error: "" };
    },
    [sanitizedRange]
  );

  const autoHighlightResult = useMemo(
    () => evaluateAutoExpr(autoHighlightExpr),
    [autoHighlightExpr, evaluateAutoExpr]
  );

  const moveRight = useMemo(
    () => compileMoveRightPredicate(moveRightExpr),
    [moveRightExpr]
  );

  const togglePathStart = useCallback((p: Point) => {
    const key = pointKey(p);
    setManualNodes((prev) => {
      if (prev.some((pt) => pointKey(pt) === key)) {
        return prev.filter((pt) => pointKey(pt) !== key);
      }
      return [...prev, p];
    });
  }, []);

  const applyAutoHighlight = useCallback(
    (expr: string, enabled: boolean) => {
      const result = evaluateAutoExpr(expr);
      setAutoHighlightExpr(expr);
      setAutoHighlightEnabled(enabled);

      const activeTransform = createTransformFunction(transformFunc);
      const moveRightPredicate = moveRight.fn;

      const getEffectiveX = (gx: number, gy: number) => {
        const offset = getRowShiftMagnitude(gy, rowShift, randomizeShift);
        if (offset > 0) {
          if (gy > 0) return gx - offset;
          if (gy < 0) return gx + offset;
        }
        return gx;
      };

      const computeBigGcd = (gx: number, gy: number): bigint | null => {
        if (!moveRightPredicate.isDefaultCoprimeRule) return null;
        if (!activeTransform.evalBigInt) return null;

        const xInt = Math.round(getEffectiveX(gx, gy));
        const yInt = Math.round(gy);

        const xBig = BigInt(xInt);
        const yBig = BigInt(yInt);

        const vXBig = activeTransform.evalBigInt(xBig);
        const vYBig = activeTransform.evalBigInt(yBig);
        if (vXBig === null || vYBig === null) return null;

        return gcdBigInt(vXBig, vYBig);
      };

      const checkGoesNorth = (gx: number, gy: number) => {
        const gcdExact = computeBigGcd(gx, gy);
        if (gcdExact !== null) return gcdExact !== 1n;

        const effectiveX = getEffectiveX(gx, gy);
        const vX = Math.round(activeTransform(effectiveX));
        const vY = Math.round(activeTransform(gy));

        try {
          return !moveRightPredicate(vX, vY);
        } catch {
          return gcd(vX, vY) !== 1;
        }
      };

      const traceForwardEnd = (start: Point, maxSteps: number): Point => {
        let currX = start.x;
        let currY = start.y;

        const canFastForward =
          transformFunc.trim().toLowerCase() === "n" ||
          transformFunc.trim().toLowerCase() === "x";

        const stepsLimit = Math.max(0, Math.floor(maxSteps));
        let stepsUsed = 0;

        while (stepsUsed < stepsLimit) {
          const goesNorth = checkGoesNorth(currX, currY);
          if (goesNorth) {
            currY += 1;
            stepsUsed += 1;
            continue;
          }

          const p = Math.abs(currY);
          const canJump = canFastForward && isPrime(p) && p > 1;
          if (!canJump) {
            currX += 1;
            stepsUsed += 1;
            continue;
          }

          const effectiveX = getEffectiveX(currX, currY);
          const rem = ((effectiveX % p) + p) % p;
          const jump = rem === 0 ? 1 : Math.min(p - rem, stepsLimit - stepsUsed);

          currX += jump;
          stepsUsed += jump;
        }

        return { x: currX, y: currY };
      };

      const probe = traceForwardEnd({ x: 100, y: 0 }, 100);
      const groundY = probe.y + 1;

      const findBottommostRightmostPredecessor = (target: Point): Point => {
        // Fast method: search for the rightmost x on the computed ground row whose forward path reaches `target`.
        // This avoids exploring the enormous reverse-reachable set.
        if (target.y < groundY) return target;

        const canFastForward =
          transformFunc.trim().toLowerCase() === "n" ||
          transformFunc.trim().toLowerCase() === "x";

        type Outcome = "hit" | "tooLeft" | "tooRight";

        const outcomeFromStartX = (startX: number): Outcome => {
          let currX = startX;
          let currY = groundY;
          let lastXAtTargetRow: number | null = null;

          // Hard cap to prevent pathological loops.
          const maxIters = 5_000_000;
          let iters = 0;

          while (iters < maxIters) {
            if (currX === target.x && currY === target.y) return "hit";
            if (currY === target.y) lastXAtTargetRow = currX;

            // If we've already passed the target row without hitting.
            if (currY > target.y) break;

            // If we overshoot target x on or before the target row, we can't ever hit it.
            if (currX > target.x && currY <= target.y) return "tooRight";

            const goesNorth = checkGoesNorth(currX, currY);
            if (goesNorth) {
              currY += 1;
              iters += 1;
              continue;
            }

            const p = Math.abs(currY);
            const canJump = canFastForward && isPrime(p) && p > 1;
            if (!canJump) {
              currX += 1;
              iters += 1;
              continue;
            }

            const effectiveX = getEffectiveX(currX, currY);
            const rem = ((effectiveX % p) + p) % p;
            const jump = rem === 0 ? 1 : p - rem;
            const nextX = currX + jump;

            // If we pass through the target on the target row during the jump, we hit it.
            if (
              currY === target.y &&
              target.x > currX &&
              target.x <= nextX
            ) {
              return "hit";
            }

            // If we pass target.x+1 before reaching the target row, we're too far right.
            if (
              currY < target.y &&
              target.x + 1 > currX &&
              target.x + 1 <= nextX
            ) {
              return "tooRight";
            }

            currX = nextX;
            iters += jump;
          }

          if (lastXAtTargetRow === null) return "tooLeft";
          if (lastXAtTargetRow < target.x) return "tooLeft";
          if (lastXAtTargetRow > target.x) return "tooRight";
          return "hit";
        };

        const maxX = Math.floor(target.x);
        const minX = maxX - 1_000_000_000;

        let probe = maxX;
        let step = 1;
        while (probe > minX && outcomeFromStartX(probe) === "tooRight") {
          probe = maxX - step;
          step *= 2;
        }
        const lowBound = Math.max(minX, probe);

        let lo = lowBound;
        let hi = maxX;
        let bestHit: number | null = null;

        while (lo <= hi) {
          const mid = Math.floor((lo + hi) / 2);
          const out = outcomeFromStartX(mid);
          if (out === "tooLeft") {
            lo = mid + 1;
            continue;
          }
          if (out === "tooRight") {
            hi = mid - 1;
            continue;
          }
          bestHit = mid;
          lo = mid + 1;
        }

        return bestHit === null ? target : { x: bestHit, y: groundY };
      };

      const nextAutoPoints =
        !enabled || result.error || result.points.length === 0
          ? ([] as Point[])
          : autoHighlightGoToGround
          ? dedupePoints(
              result.points.map((start) => {
                const end = traceForwardEnd(start, 1000);
                return findBottommostRightmostPredecessor(end);
              })
            )
          : result.points;

      const previousAutoPoints = autoGeneratedNodesRef.current;

      if (!enabled || result.error || nextAutoPoints.length === 0) {
        const autoKeys = new Set(previousAutoPoints.map((p) => pointKey(p)));
        setManualNodes((prev) =>
          prev.filter((p) => !autoKeys.has(pointKey(p)))
        );
        setAutoGeneratedNodes([]);
        return;
      }

      const autoKeys = new Set(previousAutoPoints.map((p) => pointKey(p)));
      setManualNodes((prev) => {
        const retained = prev.filter((p) => !autoKeys.has(pointKey(p)));
        return dedupePoints([...retained, ...nextAutoPoints]);
      });
      setAutoGeneratedNodes(nextAutoPoints);
    },
    [
      autoHighlightGoToGround,
      backtraceLimit,
      evaluateAutoExpr,
      moveRight.fn,
      randomizeShift,
      rowShift,
      transformFunc,
    ]
  );

  useEffect(() => {
    if (!autoHighlightEnabled) return;
    applyAutoHighlight(autoHighlightExpr, true);
  }, [autoHighlightGoToGround]);

  const resetPaths = useCallback(() => {
    setManualNodes([]);
    setAutoGeneratedNodes([]);
    setResetPathsSignal((s) => s + 1);
  }, []);

  const handleRangeChange = useCallback((next: Partial<HighlightRange>) => {
    setAutoHighlightRange((prev) => {
      const updated = { ...prev, ...next };
      return {
        min: clampInt(updated.min, 1, -2000, 2000),
        max: clampInt(updated.max, 25, -2000, 2000),
      };
    });
  }, []);

  const handleRowShiftBounds = useCallback((next: Partial<RowShiftBounds>) => {
    setRowShiftBounds((prev) => {
      const updated = resolveRowShiftBounds(next, prev);
      setRowShift((current) =>
        clampInt(current, current, updated.min, updated.max)
      );
      return updated;
    });
  }, []);

  const handlePathStepLimit = useCallback(
    (val: number) =>
      setPathStepLimit(clampInt(val, pathStepLimit, 1, 1000000)),
    [pathStepLimit]
  );

  const handleBacktraceLimit = useCallback(
    (val: number) =>
      setBacktraceLimit(clampInt(val, backtraceLimit, 1, 1000000)),
    [backtraceLimit]
  );

  const handleSaveSlot = useCallback(
    (description: string) => {
      const trimmed = description.trim();
      if (!trimmed) return;
      const snapshot = buildSettingsSnapshot();
      const nextSlot: SavedSettingsSlot = {
        id: createSlotId(),
        description: trimmed,
        savedAt: Date.now(),
        snapshot,
      };
      setSavedSlots((prev) => [nextSlot, ...prev]);
    },
    [buildSettingsSnapshot]
  );

  const handleLoadSlot = useCallback(
    (slotId: string) => {
      if (slotId === "default") {
        applySettingsSnapshot(DEFAULT_SETTINGS_SNAPSHOT, {
          syncRowShift: true,
        });
        return;
      }
      const slot = savedSlots.find((item) => item.id === slotId);
      if (!slot) return;
      applySettingsSnapshot(slot.snapshot, { syncRowShift: true });
    },
    [applySettingsSnapshot, savedSlots]
  );

  const handleDeleteSlot = useCallback((slotId: string) => {
    if (slotId === "default") return;
    setSavedSlots((prev) => prev.filter((slot) => slot.id !== slotId));
  }, []);

  const slotSummaries = useMemo(
    () =>
      [
        { id: "default", description: "Default" },
        ...savedSlots.map(({ id, description }) => ({
          id,
          description,
        })),
      ],
    [savedSlots]
  );

  return (
    <div
      className={`relative w-full h-full overflow-hidden transition-colors duration-300 select-none ${
        theme === "dark" ? "bg-gray-900" : "bg-gray-50"
      }`}
    >
      <InfiniteGraph
        viewport={viewport}
        onViewportChange={setViewport}
        theme={theme}
        transformFunc={transformFunc}
        moveRightPredicate={moveRight.fn}
        simpleView={simpleView}
        showFactored={showFactored}
        rowShift={rowShift}
        randomizeShift={randomizeShift}
        onCursorMove={setCursorPos}
        degree={degree}
        resetPathsSignal={resetPathsSignal}
        pathStarts={manualNodes}
        onTogglePathStart={togglePathStart}
        pathStepLimit={pathStepLimit}
        backtraceLimit={backtraceLimit}
        onBacktrailChange={(len) => setBacktrailLength(len)}
      />
      <Controls
        viewport={viewport}
        setViewport={setViewport}
        theme={theme}
        setTheme={setTheme}
        transformFunc={transformFunc}
        setTransformFunc={setTransformFunc}
        moveRightExpr={moveRightExpr}
        setMoveRightExpr={setMoveRightExpr}
        moveRightError={moveRight.error}
        simpleView={simpleView}
        setSimpleView={setSimpleView}
        showFactored={showFactored}
        setShowFactored={setShowFactored}
        rowShift={rowShift}
        setRowShift={setRowShift}
        rowShiftBounds={rowShiftBounds}
        setRowShiftBounds={handleRowShiftBounds}
        shiftLock={shiftLock}
        setShiftLock={setShiftLock}
        randomizeShift={randomizeShift}
        setRandomizeShift={setRandomizeShift}
        cursorPos={cursorPos}
        degree={degree}
        setDegree={setDegree}
        onResetPaths={resetPaths}
        autoHighlightExpr={autoHighlightExpr}
        autoHighlightEnabled={autoHighlightEnabled}
        onApplyAutoHighlight={applyAutoHighlight}
        autoHighlightGoToGround={autoHighlightGoToGround}
        setAutoHighlightGoToGround={setAutoHighlightGoToGround}
        autoHighlightError={autoHighlightResult.error}
        autoHighlightRange={sanitizedRange}
        setAutoHighlightRange={handleRangeChange}
        pathStepLimit={pathStepLimit}
        setPathStepLimit={handlePathStepLimit}
        backtraceLimit={backtraceLimit}
        setBacktraceLimit={handleBacktraceLimit}
        backtrailLength={backtrailLength}
        savedSlots={slotSummaries}
        onSaveSlot={handleSaveSlot}
        onLoadSlot={handleLoadSlot}
        onDeleteSlot={handleDeleteSlot}
      />
      {/* Branding / Watermark */}
      <div className="absolute bottom-4 left-4 pointer-events-none opacity-50">
        <span
          className={`text-xs font-mono ${
            theme === "dark" ? "text-gray-600" : "text-gray-400"
          }`}
        >
          Infinite GCD Explorer
        </span>
      </div>
    </div>
  );
}

export default App;
